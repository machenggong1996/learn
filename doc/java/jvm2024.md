# jvm2024

## 类加载机制

双亲委派机制

jdk8 jdk9 机制不同

### 打破双亲委派机制

1. 自定义类加载器并重写loadClass方法：‌通过自定义类加载器并重写其loadClass方法，‌可以改变类的加载方式，‌从而打破双亲委派机制。‌例如，‌Tomcat通过这种方式实现了应用之间的类隔离，‌确保每个应用可以加载其自己的类而不会受到其他应用的影响1。‌
2. 使用线程上下文类加载器：‌通过使用线程上下文类加载器（‌Thread Context ClassLoader）‌，‌可以利用SPI机制加载类。‌例如，‌JDBC和JNDI等机制就是通过这种方式加载类的，‌从而实现了对双亲委派机制的破坏1。‌
3. 使用特定的框架或技术：‌如OSGi框架，‌它实现了一套新的类加载器机制，‌允许同级之间进行类的委托加载。‌虽然这种方法目前较少使用，‌但它也是一种打破双亲委派机制的方式1。‌
4. 基于SPI的破坏方式：‌Java的SPI机制，‌如JDBC、‌Dubbo、‌Elasticsearch等，‌通过SPI机制实现了对双亲委派机制的破坏。‌这些机制在内部通过自定义类加载器或重写loadClass方法，‌使得类的加载不再遵循双亲委派模型，‌从而实现了特定功能2。‌
5. 这些方法各有特点，‌但共同点在于通过自定义类加载器或改变类的加载顺序和方式，‌来实现对双亲委派机制的破坏。‌这种破坏有助于实现一些特定的功能，‌如应用之间的类隔离、‌动态加载类等，‌但同时也可能带来一些管理和维护上的挑战

## 对象创建过程

1. new对象指令 常量池拿到类元信息，没有的话会去加载类
2. 拿到开取内存空间 分配类型根据垃圾回收器不同
3. 在Eden区存储 内存抢占
4. 初始化零值 对象头设置
5. init初始对象 init初始化非static，cinit初始化static

## 对象内存分配方式

### 栈上分配

栈上分配是指将对象分配在线程的栈帧中，而不是在堆内存中。这种方式通常用于一些短暂的、
生命周期较短的对象。由于栈帧的生命周期与线程方法的执行周期一致，因此在方法结束时，
栈帧中的对象也会随之销毁，无需进行垃圾回收。

### 堆上分配

1. 堆内存规整：已使用的内存在一边，未使用的内存在另一边
   * 指针碰撞
2. 堆内存不规整：已使用内存和未使用内存相互交错
   * 空闲列表 存储未使用的内存

## jvm创建对象如何解决多线程内存抢占

在Java虚拟机（JVM）中，多线程环境下创建对象时可能会遇到内存抢占（Thread Interference）的问题。这种情况通常发生在多线程环境下，多个线程试图在同一时间内创建同一类型的对象，并且这个对象的初始化没有被正确地同步时。

解决多线程内存抢占问题的方法通常有以下几种：

1. CAS
2. TLAB
3. synchronized关键字
4. volatile关键字

线程私有分配缓冲区（Thread Local Allocation Buffer, TLAB）

JVM在Java堆中为每个线程分配了一个私有的内存分配缓冲区（TLAB），用于对象的快速分配。TLAB的作用包括：

减少线程之间的竞争：每个线程都有自己的TLAB，避免了多线程之间的竞争，提高了分配效率。
延迟同步：线程在TLAB中分配对象时，不需要加锁，只有当TLAB空间不足时才需要进行同步操作。
线程安全的内存分配指针

JVM为每个线程维护了一个线程本地的内存分配指针（Allocation Pointer），用于标记下一个可以分配对象的位置。每次分配对象时，线程会使用这个指针来确定在TLAB中的分配位置，从而保证了线程安全性。

synchronized关键字

volatile关键字

## 对象内存布局和大小计算

[对象内存布局和大小计算](https://www.cnblogs.com/wzjhoutai/p/7093174.html)

对象在内存中存储的布局能够分为三块区域：
对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

1. 对象头：锁状态信息，GC分代年龄 32位和64位占用内存不一样 存储对像类型的指针
2. 实例数据：代码中定义的字段内容
3. 对齐填充区域：占位符，非必须 对象大小必须是8字节的整数倍，对象填充进行补齐

## jvm内存泄露的原因

内存使用之后没有及时释放1，垃圾没有回收

1. 静态集合
2. 单例模式
3. 数据库连接 IO socket,使用完之后要close
4. hash值变化，无法找到存入的对象
5. ThreadLocal没有remove

## 如何判断对象仍然存活

[判断对象是否存活](https://blog.csdn.net/mj879158775/article/details/123732068)

如果某个对象到GC Roots间没有任何引用链相连，则证明改对象是不可能再被使用的

* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量
* 在方法区中类静态属性引用的对象，如Java类的引用类型静态变量
* 在方法区中常量引用的对象，如字符串常量池里的引用
* 在本地方法栈中JNI（Native方法）引用的对象
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些异常对象（如NullPointException，OutOfMemoryError）等，还有系统类加载器
* 所有被synchronized关键字持有的对象
* 反映Java虚拟机内部情况的JMXBean，JVMTI中注册的回调，本地代码缓存等

## 垃圾回收算法

## 三色标记法 优缺点 过程

[三色标记法](https://blog.csdn.net/oJieSi/article/details/134758659)

三色指的是白色，灰色，黑色（white，gray，black）。抽象的理解，可以认为垃圾收集器在标记阶段将对象染成不同的颜色，根据不同的颜色做不同处理。那么三种染色的对象分别指什么呢？

* 白色
  - 1- 在标记开始时，堆内存中的对象都是白色的。
  - 2- 在标记结束时，仍然是白色的对象，将会被视为已死的对象而被清除。
* 灰色
  - 灰色是由白色标记成为灰色，表示该对象Obj是根可达对象（存活的对象，不会被清理）,但Obj的所有引用的对象还没被垃圾收集器访问；灰色是一个过渡色，最终都会被标记为黑色。
* 黑色
  - 黑色是由灰色标记成为黑色，表示该对象Obj以及Obj的所有下级引用对象都已经被垃圾收集器访问并标记，Obj不会被垃圾收集器再次访问以查看是否有引用对象；
  - 此时Obj是黑色（存活的对象，不会被清理），Obj的所有引用的对象被标记为灰色。

使用三个set进行统计，最开始都在whiteSet,标记进入GreySet,再进入BlackSet

优点：三色标记法在并发环境中表现良好，能够有效地标记存活和死亡的对象，从而提高垃圾回收的效率。
缺点：在并发环境中，标记线程和用户线程同时执行可能会导致误标（错误地标记某些对象为存活），这需要通过读写屏障等技术来解决。此外，三色标记法需要额外的数据结构来跟踪对象的颜色状态，这可能会增加内存开销。‌

### CMS中三色标记法

1. 初始标记（CMS initial mark），根节点直接引用的对象标记为灰色（短暂的STW）
2. 并发标记（CMS concurrent mark）扫描灰色对象引用的对象并标记为灰色，原灰色对象标记为黑色
3. 重新标记（CMS remark）增量更新方案矫正并发标记阶段的错误（短暂的STW）
4. 并发清除（CMS concurrent sweep）清除白色的对象，内存回收

### G1中三色标记法

1. 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象
2. 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析
3. 最终标记（Final Marking）：原始快照方案处理并发阶段结束后仍遗留SATB记录
4. 筛选回收（Live Data Counting and Evacuation）：根据用户期望的停顿时间来制定回收计划

### 读写屏障

[读写屏障](https://blog.csdn.net/qq_21383435/article/details/106311542)

### 存在的问题

因为是异步标记,可能有连接断开，其他的也变成垃圾，老年代80-90%就会回收，应对浮动垃圾

1. 浮动垃圾：可能有连接断开，其他的也变成垃圾，老年代80-90%就会回收，应对浮动垃圾，留给下次标记就行
2. 对象漏标：异步过程中突然垃圾被引用了
  - cms对增加引用环节进行处理
  - G1对删除引用环节进行处理

## CMS垃圾回收的过程

1. 初始标记（CMS initial mark），根节点直接引用的对象标记为灰色（短暂的STW）
2. 并发标记（CMS concurrent mark）扫描灰色对象引用的对象并标记为灰色，原灰色对象标记为黑色
3. 重新标记（CMS remark）增量更新方案矫正 并发标记 阶段的错误（短暂的STW），修正并发标记引用改变的问题
4. 并发清除（CMS concurrent sweep）清除白色的对象，内存回收

## G1垃圾回收器

不再区分Eden 老年代等这些区，将堆分为一块一块的小区（region），每一个区域都根据需要扮演Eden，Survivor，老年代，根据不同的角色使用不同的策略

可预测的停顿时间，精细的控制，内存碎片的控制，优先级处理（优先回收内存大的区域）

需要更大的堆内存支撑

### G1标记过程

1. 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象
2. 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析
3. 最终标记（Final Marking）：原始快照方案处理并发阶段结束后仍遗留SATB记录，将异步标记将引用改变的对象重新标记
4. 筛选回收（Live Data Counting and Evacuation）：根据用户期望的停顿时间来制定回收计划，将回收region的对象

## 有了CMS为什么还要G1

jdk8 CMS G1
jdk10 - 13 G1

1. 大内存当中G1发挥的更好
2. CMS并发收集，低停顿，G1有这个，但是需要更大的内存支撑
3. CMS有三个明显缺点
   * Mark sweep算法会导致内存碎片过多
   * 并发收集会抢占用户线程的资源，导致程序性能下降
   * 并发清除阶段会产生浮动垃圾，留给下一次垃圾回收，浮动垃圾过多，会触发新的垃圾回收导致性能降低


