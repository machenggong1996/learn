# REDIS 2024


## zset底层数据结构

添加元素：使用ZADD命令向ZSET中添加元素和分数。
获取元素：通过ZRANGE或ZREVRANGE命令获取指定范围内的元素。
获取分数：使用ZSCORE命令获取指定元素的分数。
删除元素：使用ZREM命令从ZSET中删除一个或多个元素。

压缩列表和跳表

压缩列表使用：当有序集合保存的元素小于128个或者保存的所有元素的长度小于64字节的时候会使用

### 跳表和B+树区别

* [MySQL B+树索引 和 Redis 中跳表索引的区别](https://blog.csdn.net/qq_43692950/article/details/136881398)

跳表：查找 插入 删除 时间复杂度log(n) 是一种二分查找

跳跃表层级使用随机概率增加层数（幂次定律 越大的数出现次数越小）

放同样量的数据 B+树层级更低IO次数小，跳表层级高IO次数多

mysql是磁盘IO，redis内存IO，内存远远快于磁盘所以层高不再是问题

B+树要保持树的平衡，跳表不需要所以开销小

MySQL 是磁盘存储的数据库系统，其中性能瓶颈在于磁盘IO的性能，而 B+树，以叶子节点和非叶子节点存储多索引的方式极大降低树的层级，在磁盘访问时能够保持较好的局部性，也大大降低了磁盘的读取次数，可以有效提升读取的性能。而跳表由于其随机指针的特性，在磁盘访问时可能导致更多的随机IO操作，影响访问效率。跳表在存储空间利用率上也不占优势。跳表需要维护多级索引，可能会导致额外的空间消耗，尤其是在数据量较大时，这种空间开销会变得非常显著。因此对比下来， B+树更适合 MySQL 。

而 Redis 是基于内存的数据库，数据操作都在内存中进行，无需关注磁盘IO，所以即使层级增大也影响不大，但是 B+树写数据时需要进行树平衡操作，反而影响了写的性能。而且跳表相对于B+树来说实现更加简单，代码量更少，容易理解和维护。在内存数据库中，简单且高效的实现是非常重要的考虑因素。跳表在支持范围查询方面比较灵活，插入、删除和查找操作的时间复杂度都是O(log n)，这使得跳表在处理范围查询时表现较好。因此对比下来 Reids 中跳表的效果更好。
