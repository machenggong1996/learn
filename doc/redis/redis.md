# redis

## 分布式锁

[分布式锁](https://blog.csdn.net/dazou1/article/details/88088223)

1. setnx 是『SET if Not eXists』(如果不存在，则 SET)的简写。 命令格式：SETNX key value；使用：只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。返回值：命令在设置成功时返回 1 ，设置失败时返回 0 。
2. getset 命令格式：GETSET key value，将键 key 的值设为 value ，并返回键 key 在被设置之前的旧的value。返回值：如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil 。当键 key 存在但不是字符串类型时，命令返回一个错误。
3. expire 命令格式：EXPIRE key seconds，使用：为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。返回值：设置成功返回 1 。 当 key 不存在或者不能为 key 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的生存时间)，返回 0 。
4. del 命令格式：DEL key [key …]，使用：删除给定的一个或多个 key ，不存在的 key 会被忽略。返回值：被删除 key 的数量。

## 缓存穿透 缓存击穿 缓存雪崩

* [Redis-缓存穿透、缓存击穿](https://zhuanlan.zhihu.com/p/62558432)

### 缓存穿透

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

解决方案：id和用户信息校验
* 布隆过滤器
* 设置空值在数据库

### 缓存雪崩

缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

解决方案：
* 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
* 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
* 设置热点数据永远不过期。

### 缓存击穿

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。

解决方案：
1. 设置热点数据永远不过期。
2. 接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务  不可用时候，进行熔断，失败快速返回机制。
3. 布隆过滤器。bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小
4. 加互斥锁

### rdb与aof

两种方式同时存在的时候优先加载aof

#### rdb触发方式

1. save
2. bgsave 异步
3. 自动触发

#### aof

记录写操作命令日志

* 每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 
性能较差但数据完整性比较好，最多丢一个时间事件循环的数据
* 每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失
* 不同no：从不同步

### 跳跃表

[跳跃表原理](https://blog.csdn.net/wei_gg/article/details/92407489)

### docker安装redis集群

[docker安装redis集群](https://github.com/modouxiansheng/about-docker/tree/master/redis-cluster)

### redis事件

#### 文件处理事件

处理命令请求，命令会进入队列进行排队，然后多线程进入不同处理器

#### 时间处理事件

* 主动删除过期的键（也可以在读数据库时被动删除）
* 喂看门狗 watchdog
* 更新一些统计值
* 渐进式rehash
* 触发AOF 的重写操作(重写开启新进程)
* 如果AOF正在重写,接受重写结束后的信号,将子进程里的临时aof文件写入磁盘,并将部分重写缓冲追加进aof文件
* 触发AOF缓冲写入 内核/磁盘(刷新开启新线程)
* 不同状态的client的超时
* 复制重连

### aof rewrite 不能保证100%不丢数据

先把写命令追加到aof buffer中，下一次进入事件循环循环后，再将buffer写到磁盘上。结合while循环处方法的调用顺序，可以看出确实是这样的。那么也就是说，这次写到磁盘上的内容是上一个事件循环产生的所以，即使设置为always，也会丢失一个循环的数据。